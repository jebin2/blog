<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Quick Infographics</title>
	<style>
		body {
			font-family: sans-serif;
			margin: 0;
			padding: 20px;
			background: #f7f7f7;
		}

		.grid {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
			gap: 15px;
		}

		.grid img {
			width: 100%;
			height: auto;
			cursor: pointer;
			border: 1px solid #ccc;
			border-radius: 5px;
			transition: transform 0.2s;
		}

		.grid img:hover {
			transform: scale(1.05);
		}

		/* Modal */
		.modal {
			display: none;
			position: fixed;
			z-index: 999;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.9);
			overflow: hidden;
			/* Important: hides parts of image outside the viewport */
		}

		.modal-content {
			width: 100%;
			height: 100%;
		}

		/* The image is positioned absolutely to be controlled by transform */
		.modal-content img {
			position: absolute;
			top: 0;
			left: 0;
			user-select: none;
			-webkit-user-select: none;
			/* We use transform-origin: 0 0 for simpler calculations */
			transform-origin: 0 0;
			background: white;
		}

		.close {
			position: fixed;
			top: 15px;
			right: 25px;
			font-size: 40px;
			font-weight: bold;
			color: #fff;
			cursor: pointer;
			z-index: 1000;
			line-height: 1;
			text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
			background: rgba(220, 20, 60, 0.8);
			width: 50px;
			height: 50px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.close:hover {
			background: rgba(220, 20, 60, 1);
		}

		.zoom-info {
			position: fixed;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.7);
			color: white;
			padding: 10px 20px;
			border-radius: 20px;
			font-size: 14px;
			z-index: 1000;
			pointer-events: none;
		}
	</style>
</head>

<body>

	<h1>Quick Infographics</h1>
	<div class="grid" id="svgGrid"></div>

	<!-- Modal -->
	<div id="svgModal" class="modal">
		<span class="close">&times;</span>
		<div class="modal-content">
			<img id="modalImg" src="" alt="SVG">
		</div>
		<div class="zoom-info" id="zoomInfo">100%</div>
	</div>

	<script>
		const repoUrl = 'https://raw.githubusercontent.com/jebin2/blog/main/manifest.json';
		const svgGrid = document.getElementById('svgGrid');
		const modal = document.getElementById('svgModal');
		const modalImg = document.getElementById('modalImg');
		const closeBtn = modal.querySelector('.close');
		const zoomInfo = document.getElementById('zoomInfo');

		// State variables for zoom and pan
		let scale = 1;
		let translateX = 0;
		let translateY = 0;
		let isPanning = false;
		let panStart = { x: 0, y: 0 };
		let allSvgs = [];
		let initialTouchState = null;

		// --- Data Loading and Initialization ---
		async function loadSVGs() {
			try {
				const response = await fetch(repoUrl);
				const manifest = await response.json();
				allSvgs = manifest.svgs;

				allSvgs.forEach(svg => {
					const img = document.createElement('img');
					img.src = `https://raw.githubusercontent.com/jebin2/blog/main/${svg.path}`;
					img.alt = svg.name;
					img.dataset.path = svg.path;
					img.addEventListener('click', () => openModal(img.src, svg.path));
					svgGrid.appendChild(img);
				});
			} catch (err) {
				svgGrid.innerHTML = `<div class="error">Error loading SVGs: ${err.message}</div>`;
			}
		}

		// --- URL Management ---
		function checkUrlParameter() {
			const urlParams = new URLSearchParams(window.location.search);
			const srcParam = urlParams.get('src');
			if (srcParam) {
				const fullPath = `https://raw.githubusercontent.com/jebin2/blog/main/${srcParam}`;
				openModal(fullPath, srcParam);
			}
		}

		function updateUrl(svgPath) {
			const url = new URL(window.location);
			url.searchParams.set('src', svgPath);
			window.history.pushState({}, '', url);
		}

		function clearUrl() {
			const url = new URL(window.location);
			url.searchParams.delete('src');
			window.history.pushState({}, '', url);
		}

		// --- Modal and Transform Logic ---
		function openModal(src, svgPath) {
			modal.style.display = 'block';
			updateUrl(svgPath);
			modalImg.src = src;
			modalImg.style.cursor = 'default';
		}

		function closeModal() {
			modal.style.display = 'none';
			clearUrl();
		}

		function applyTransform() {
			modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
			updateZoomInfo();
		}

		function fitAndCenterImage(e) {
			const zoomSpeed = 1.2;
			const newScale = scale * zoomSpeed;
			const clampedScale = Math.max(0.1, Math.min(20, newScale));

			const imageX = (e.clientX - translateX) / scale;
			const imageY = (e.clientY - translateY) / scale;

			translateX = e.clientX - imageX * clampedScale;
			translateY = e.clientY - imageY * clampedScale;
			scale = clampedScale;

			applyTransform();
		}

		function updateZoomInfo() {
			zoomInfo.textContent = `${Math.round(scale * 100)}%`;
		}

		// --- Event Listeners ---
		closeBtn.onclick = closeModal;
		window.addEventListener('keydown', e => {
			if (e.key === 'Escape') closeModal();
		});
		window.addEventListener('popstate', () => {
			const urlParams = new URLSearchParams(window.location.search);
			const srcParam = urlParams.get('src');
			if (srcParam) {
				const fullPath = `https://raw.githubusercontent.com/jebin2/blog/main/${srcParam}`;
				openModal(fullPath, srcParam);
			} else {
				closeModal();
			}
		});

		// --- Panning with Mouse ---
		modalImg.addEventListener('mousedown', e => {
			e.preventDefault();
			isPanning = true;
			panStart.x = e.clientX - translateX;
			panStart.y = e.clientY - translateY;
			modalImg.style.cursor = 'grabbing';
		});

		window.addEventListener('mouseup', () => {
			isPanning = false;
			modalImg.style.cursor = 'default';
		});

		window.addEventListener('mouseleave', () => {
			isPanning = false;
			modalImg.style.cursor = 'default';
		});

		window.addEventListener('mousemove', e => {
			if (!isPanning) return;
			e.preventDefault();
			translateX = e.clientX - panStart.x;
			translateY = e.clientY - panStart.y;
			applyTransform();
		});

		// --- Zooming with Mouse Wheel ---
		modal.addEventListener('wheel', e => {
			e.preventDefault();
			const zoomSpeed = 1.2;
			const newScale = e.deltaY < 0 ? scale * zoomSpeed : scale / zoomSpeed;
			const clampedScale = Math.max(0.1, Math.min(20, newScale));

			const imageX = (e.clientX - translateX) / scale;
			const imageY = (e.clientY - translateY) / scale;

			translateX = e.clientX - imageX * clampedScale;
			translateY = e.clientY - imageY * clampedScale;
			scale = clampedScale;

			applyTransform();
		});

		// --- Touch Support for Pan and Pinch-Zoom ---
		function getDistance(t1, t2) {
			const dx = t1.clientX - t2.clientX;
			const dy = t1.clientY - t2.clientY;
			return Math.sqrt(dx * dx + dy * dy);
		}

		function getMidpoint(t1, t2) {
			return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
		}

		modalImg.addEventListener('touchstart', e => {
			e.preventDefault();
			if (e.touches.length === 1) {
				isPanning = true;
				panStart.x = e.touches[0].clientX - translateX;
				panStart.y = e.touches[0].clientY - translateY;
			} else if (e.touches.length === 2) {
				isPanning = false;
				initialTouchState = {
					distance: getDistance(e.touches[0], e.touches[1]),
					midpoint: getMidpoint(e.touches[0], e.touches[1]),
					scale: scale,
					translateX: translateX,
					translateY: translateY,
				};
			}
		});

		modalImg.addEventListener('touchmove', e => {
			e.preventDefault();
			if (isPanning && e.touches.length === 1) {
				translateX = e.touches[0].clientX - panStart.x;
				translateY = e.touches[0].clientY - panStart.y;
				applyTransform();
			} else if (e.touches.length === 2 && initialTouchState) {
				const currentDistance = getDistance(e.touches[0], e.touches[1]);
				const currentMidpoint = getMidpoint(e.touches[0], e.touches[1]);

				const scaleChange = currentDistance / initialTouchState.distance;
				const newScale = initialTouchState.scale * scaleChange;
				scale = Math.max(0.1, Math.min(20, newScale));

				const imageX = (initialTouchState.midpoint.x - initialTouchState.translateX) / initialTouchState.scale;
				const imageY = (initialTouchState.midpoint.y - initialTouchState.translateY) / initialTouchState.scale;

				translateX = currentMidpoint.x - imageX * scale;
				translateY = currentMidpoint.y - imageY * scale;

				applyTransform();
			}
		});

		modalImg.addEventListener('touchend', e => {
			if (e.touches.length === 0) {
				isPanning = false;
				initialTouchState = null;
			} else if (e.touches.length === 1) {
				isPanning = true;
				initialTouchState = null;
				panStart.x = e.touches[0].clientX - translateX;
				panStart.y = e.touches[0].clientY - translateY;
			}
		});

		// Double-click to reset view
		modalImg.addEventListener('dblclick', fitAndCenterImage);

		// Reset view on window resize
		window.addEventListener('resize', (e) => {
			if (modal.style.display === 'block') {
				fitAndCenterImage(e);
			}
		});

		// --- Initialize ---
		checkUrlParameter();
		loadSVGs();
	</script>
</body>

</html>
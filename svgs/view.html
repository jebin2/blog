<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Quick Learn</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
			background: #1a1a1a;
			padding: 20px;
		}

		.header {
			max-width: 1400px;
			margin: 0 auto 30px;
		}

		h1 {
			color: white;
			margin-bottom: 20px;
			font-size: 2em;
		}

		.search-bar {
			width: 100%;
			/* max-width: 600px; */
			padding: 12px 20px;
			font-size: 16px;
			border: 2px solid #ddd;
			border-radius: 25px;
			outline: none;
			transition: border-color 0.3s;
		}

		.search-bar:focus {
			border-color: #4a90e2;
		}

		.svg-grid {
			max-width: 1400px;
			margin: 0 auto;
			column-count: 5;
			column-gap: 15px;
		}

		@media (max-width: 1200px) {
			.svg-grid {
				column-count: 4;
			}
		}

		@media (max-width: 900px) {
			.svg-grid {
				column-count: 3;
			}
		}

		@media (max-width: 600px) {
			.svg-grid {
				column-count: 2;
			}
		}

		.svg-item {
			break-inside: avoid;
			margin-bottom: 15px;
			background: white;
			border-radius: 8px;
			overflow: hidden;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
			cursor: pointer;
			transition: transform 0.2s, box-shadow 0.2s;
		}

		.svg-item:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
		}

		.svg-item img {
			width: 100%;
			height: auto;
			display: block;
		}

		.svg-name {
			padding: 10px;
			font-size: 12px;
			color: #666;
			background: #fafafa;
		}

		.modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.9);
			z-index: 1000;
			justify-content: center;
			align-items: center;
		}

		.modal.active {
			display: flex;
		}

		.modal-content {
			position: relative;
			width: 90%;
			height: 90%;
			overflow: hidden;
			cursor: grab;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.modal-content:active {
			cursor: grabbing;
		}

		.modal-image {
			max-width: 100%;
			max-height: 100%;
			transition: transform 0.1s ease-out;
			user-select: none;
			-webkit-user-select: none;
			transform-origin: center center;
			background: white;
		}

		.modal-close {
			position: absolute;
			top: 20px;
			right: 20px;
			font-size: 40px;
			color: white;
			cursor: pointer;
			z-index: 1001;
			width: 50px;
			height: 50px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: rgba(0, 0, 0, 0.5);
			border-radius: 50%;
			transition: background 0.2s;
		}

		.modal-close:hover {
			background: rgba(0, 0, 0, 0.8);
		}

		.zoom-controls {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			display: flex;
			gap: 10px;
			z-index: 1001;
		}

		.zoom-btn {
			width: 50px;
			height: 50px;
			background: rgba(0, 0, 0, 0.7);
			color: white;
			border: none;
			border-radius: 50%;
			font-size: 24px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: background 0.2s;
		}

		.zoom-btn:hover {
			background: rgba(0, 0, 0, 0.9);
		}

		.error {
			color: #e74c3c;
			text-align: center;
			padding: 20px;
			font-size: 16px;
		}

		.loading {
			text-align: center;
			padding: 40px;
			color: #666;
			font-size: 18px;
		}
	</style>
</head>

<body>
	<div class="header">
		<h1>Quick Learn</h1>
		<input type="text" class="search-bar" id="searchBar" placeholder="Search...">
	</div>

	<div class="svg-grid" id="svgGrid">
		<div class="loading">Loading SVGs...</div>
	</div>

	<div class="modal" id="modal">
		<span class="modal-close" id="modalClose">&times;</span>
		<div class="modal-content" id="modalContent">
			<img class="modal-image" id="modalImage" src="" alt="">
		</div>
		<div class="zoom-controls">
			<button class="zoom-btn" id="zoomOut">−</button>
			<button class="zoom-btn" id="zoomReset">⟲</button>
			<button class="zoom-btn" id="zoomIn">+</button>
		</div>
	</div>

	<script>
		const repoUrl = 'https://raw.githubusercontent.com/jebin2/blog/main/manifest.json';
		const svgGrid = document.getElementById('svgGrid');
		const searchBar = document.getElementById('searchBar');
		const modal = document.getElementById('modal');
		const modalImage = document.getElementById('modalImage');
		const modalContent = document.getElementById('modalContent');
		const modalClose = document.getElementById('modalClose');
		const zoomIn = document.getElementById('zoomIn');
		const zoomOut = document.getElementById('zoomOut');
		const zoomReset = document.getElementById('zoomReset');

		let allSvgs = [];
		let scale = 1;
		let translateX = 0;
		let translateY = 0;
		let isDragging = false;
		let startX, startY;

		async function loadSVGs() {
			try {
				const response = await fetch(repoUrl);
				const manifest = await response.json();
				allSvgs = manifest.svgs;

				displaySVGs(allSvgs);
			} catch (err) {
				svgGrid.innerHTML = `<div class="error">Error loading SVGs: ${err.message}</div>`;
			}
		}

		// --- URL Management ---
		function checkUrlParameter() {
			const urlParams = new URLSearchParams(window.location.search);
			const srcParam = urlParams.get('src');
			if (srcParam) {
				const fullPath = `https://raw.githubusercontent.com/jebin2/blog/main/${srcParam}`;
				openModal(fullPath, srcParam);
			}
		}

		function updateUrl(svgPath) {
			const url = new URL(window.location);
			url.searchParams.set('src', svgPath);
			window.history.pushState({}, '', url);
		}

		function clearUrl() {
			const url = new URL(window.location);
			url.searchParams.delete('src');
			window.history.pushState({}, '', url);
		}

		function displaySVGs(svgs) {
			svgGrid.innerHTML = '';

			if (svgs.length === 0) {
				svgGrid.innerHTML = '<div class="error">No SVGs found</div>';
				return;
			}

			svgs.forEach(svg => {
				const item = document.createElement('div');
				item.className = 'svg-item';

				const img = document.createElement('img');
				img.src = `https://raw.githubusercontent.com/jebin2/blog/main/${svg.path}`;
				img.alt = svg.name;
				img.loading = 'lazy';

				const name = document.createElement('div');
				name.className = 'svg-name';
				name.textContent = svg.name;

				item.appendChild(img);
				item.appendChild(name);
				item.addEventListener('click', () => openModal(img.src, svg.path));

				svgGrid.appendChild(item);
			});
		}

		function openModal(src, srcParam) {
			updateUrl(srcParam);
			modalImage.src = src;
			modal.classList.add('active');
			resetZoom();
			document.body.style.overflow = 'hidden';

			// Wait for image to load to get correct dimensions
			modalImage.onload = () => {
				resetZoom();
			};
		}

		function closeModal() {
			modal.classList.remove('active');
			document.body.style.overflow = 'auto';
			clearUrl();
		}

		function updateTransform() {
			modalImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
		}

		function resetZoom() {
			scale = 1;
			translateX = 0;
			translateY = 0;
			updateTransform();
		}

		// Search functionality
		searchBar.addEventListener('input', (e) => {
			const searchTerm = e.target.value.toLowerCase();
			const filtered = allSvgs.filter(svg =>
				svg.name.toLowerCase().includes(searchTerm) ||
				svg.path.toLowerCase().includes(searchTerm)
			);
			displaySVGs(filtered);
		});

		// Modal controls
		modalClose.addEventListener('click', closeModal);
		modal.addEventListener('click', (e) => {
			if (e.target === modal) closeModal();
		});

		zoomIn.addEventListener('click', () => {
			scale = Math.min(scale + 0.2, 5);
			updateTransform();
		});

		zoomOut.addEventListener('click', () => {
			scale = Math.max(scale - 0.2, 0.5);
			updateTransform();
		});

		zoomReset.addEventListener('click', resetZoom);

		// Wheel zoom with cursor point
		modalContent.addEventListener('wheel', (e) => {
			e.preventDefault();

			// Get mouse position relative to the image element
			const imgRect = modalImage.getBoundingClientRect();
			const mouseX = e.clientX - imgRect.left;
			const mouseY = e.clientY - imgRect.top;

			// Current image dimensions
			const currentWidth = imgRect.width;
			const currentHeight = imgRect.height;

			const delta = e.deltaY > 0 ? -0.1 : 0.1;
			const newScale = Math.max(0.5, Math.min(5, scale + delta));

			// Calculate the ratio of mouse position within the image
			const ratioX = mouseX / currentWidth;
			const ratioY = mouseY / currentHeight;

			// Calculate how much the image will grow/shrink
			const scaleDiff = newScale - scale;

			// Adjust translation to keep the point under cursor fixed
			translateX -= (mouseX - currentWidth / 2) * scaleDiff / scale;
			translateY -= (mouseY - currentHeight / 2) * scaleDiff / scale;

			scale = newScale;
			updateTransform();
		});

		// Drag functionality
		modalContent.addEventListener('mousedown', (e) => {
			if (e.target === modalImage || e.target === modalContent) {
				e.preventDefault();
				isDragging = true;
				startX = e.clientX - translateX;
				startY = e.clientY - translateY;
				modalContent.style.cursor = 'grabbing';
			}
		});

		document.addEventListener('mousemove', (e) => {
			if (isDragging) {
				e.preventDefault();
				translateX = e.clientX - startX;
				translateY = e.clientY - startY;
				updateTransform();
			}
		});

		document.addEventListener('mouseup', () => {
			if (isDragging) {
				isDragging = false;
				modalContent.style.cursor = 'grab';
			}
		});

		// Touch support
		let touchStartX, touchStartY, touchStartDist;

		modalContent.addEventListener('touchstart', (e) => {
			if (e.touches.length === 1) {
				isDragging = true;
				touchStartX = e.touches[0].clientX - translateX;
				touchStartY = e.touches[0].clientY - translateY;
			} else if (e.touches.length === 2) {
				isDragging = false;
				touchStartDist = Math.hypot(
					e.touches[0].clientX - e.touches[1].clientX,
					e.touches[0].clientY - e.touches[1].clientY
				);
			}
		});

		modalContent.addEventListener('touchmove', (e) => {
			e.preventDefault();
			if (e.touches.length === 1 && isDragging) {
				translateX = e.touches[0].clientX - touchStartX;
				translateY = e.touches[0].clientY - touchStartY;
				updateTransform();
			} else if (e.touches.length === 2) {
				const dist = Math.hypot(
					e.touches[0].clientX - e.touches[1].clientX,
					e.touches[0].clientY - e.touches[1].clientY
				);
				scale = Math.max(0.5, Math.min(5, scale * (dist / touchStartDist)));
				touchStartDist = dist;
				updateTransform();
			}
		});

		modalContent.addEventListener('touchend', () => {
			isDragging = false;
		});

		// Keyboard shortcuts
		document.addEventListener('keydown', (e) => {
			if (!modal.classList.contains('active')) return;

			if (e.key === 'Escape') closeModal();
			if (e.key === '+' || e.key === '=') {
				scale = Math.min(scale + 0.2, 5);
				updateTransform();
			}
			if (e.key === '-' || e.key === '_') {
				scale = Math.max(scale - 0.2, 0.5);
				updateTransform();
			}
			if (e.key === '0') resetZoom();
		});

		// Load SVGs on page load
		checkUrlParameter();
		loadSVGs();
	</script>
</body>

</html>